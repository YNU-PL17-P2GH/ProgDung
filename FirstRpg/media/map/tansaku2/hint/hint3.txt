ナイトのヒント

アルゴリズム１

ナイトツアー問題とは普通は8*8の64マスすべてを通るようにチェスのナイトを動かすことができるかという問題です。チェスのナイトの動きは8種類ありますね。(十字方向に2マス進み進行方向に対して左右いずれか1マス進みます。4*2=8種類)これをバックトラックアルゴリズムを使って解きます。バックトラックアルゴリズムの直感的な説明としては、いけるとこまでいってダメになったら戻って別の手を打つというものだと思っていいでしょう。ナイトをnステップ動かせるかどうかを判定するメソッドを考えましょう。このメソッドを考えるとバックトラックを使うタイミングが分かってくるはずです。これを手作業でやる時のことを考えると、まず、ナイトが動かせるマスがあるかどうか探す。あれば動かす。次にナイトを動かす前に、動かせるマスがあるかどうか判定する。動かせるなら動かす。動かせなければバックトラックする。これを繰り返す。そしてこの4行そのものがナイトツアー可能かどうかを判定するアルゴリズムであると分かると思います。また、繰り返しであるから、再帰を使えば簡単に書けそうです。再帰を使ったメソッドの大枠を考えましょう。ナイトをnステップ動かせるかどうか判定するメソッド()	ifナイトが次どこかのマスに動かせる		ナイトを動かす()		ifナイトをn+1ステップ動かせるかどうか判定 then			return true		else			バックトラックする		end	end	return falseendまた、このメソッドは0ステップ目から始まることを考えると、総マス数-1ステップまで到達すれば終了してよいはずです。また移動候補は8通りあるので、どのマスに対しても到達可能マスが見つかるまで8回繰り返して判定すればよいはずです。

アルゴリズム２ー貪欲法

貪欲法で解けることが知られています。ワーンスドロフの規則に従うとうまくいくことが知られています。あるマスに飛び移ったとき、そのマスからさらに飛び移ることのできるすべてのマスを拾う。そして、それぞれのマスからさらに何個のマスへ飛び移れるかをカウントして、最少の飛び方しかできないマスに実際に飛び移る。貪欲法はお金を支払う問題にたとえられ、555円を最少の硬貨数で支払うときに大きな硬貨から順に取り出すとわかりやすいですね。これと同様に飛び方が一番少ないマスから順に飛んでいく点が貪欲法であります。ただし、この規則で必ず解けることは証明されておらず有名な未解決問題とされています。最少の飛び方を探すメソッドgetNextJumps(knight)を考えましょう。最小値を探す問題と同じです。knight.move(i)とcanMove(i)を使ってナイトを動かして、次のマスへ進めるかどうかを判定、カウントしましょう。戻るときはknight.backtrack()です。
